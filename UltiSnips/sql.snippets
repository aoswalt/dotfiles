snippet sel "select (columns:*) from table"
select ${2:*} from ${1} $0
endsnippet

snippet selfun "select function definition" b
select pg_get_functiondef('${0:aspire.function_name}' :: regproc)
endsnippet

snippet selmats "list materialized views" b
select oid::regclass::text from pg_class where relkind = 'm'
endsnippet

snippet running "show running queries" b
select
    psa.pid
  , now() - psa.query_start as running_time
  , psa.client_addr
  , psa.client_port
  , psa.application_name
  , psa.state
  , psa.query
from pg_stat_activity psa
where psa.state <> 'idle'::text and psa.query !~ 'running_queries'::text
order by psa.query_start
endsnippet

snippet selview "get view definition" b
select pg_get_viewdef(oid)
from pg_class
where relname = '${0:view_name}'
endsnippet

snippet selchecks "list all check constraints" b
select
    nsp.nspname || '.' || rel.relname "table"
  , con.conname as constraint_name
  , con.consrc as definition
from pg_catalog.pg_constraint con
join pg_catalog.pg_class rel
  on rel.oid = con.conrelid
join pg_catalog.pg_namespace nsp
  on nsp.oid = connamespace
where con.contype = 'c' -- check constraint
order by nsp.nspname, rel.relname
endsnippet

snippet seluidx "list all unused indices" b
select
    s.schemaname
  , s.relname as tablename
  , s.indexrelname as indexname
  , pg_relation_size(s.indexrelid) as index_size
from pg_catalog.pg_stat_user_indexes s
join pg_catalog.pg_index i
  on s.indexrelid = i.indexrelid
where s.idx_scan = 0      -- has never been scanned
  and 0 <> all(i.indkey)  -- no index column is an expression
  and not i.indisunique   -- is not a unique index
  and not exists          -- does not enforce a constraint
      (select 1 from pg_catalog.pg_constraint c
        where c.conindid = s.indexrelid)
order by pg_relation_size(s.indexrelid) desc
endsnippet

snippet seldeps "find dependencies" b
select dependent_ns.nspname as dependent_schema
  , dependent_view.relname as dependent_view
  , source_ns.nspname as source_schema
  , source_table.relname as source_table
  , pg_attribute.attname as column_name
from pg_depend
  join pg_rewrite on pg_depend.objid = pg_rewrite.oid
  join pg_class as dependent_view on pg_rewrite.ev_class = dependent_view.oid
  join pg_class as source_table on pg_depend.refobjid = source_table.oid
  join pg_attribute on pg_depend.refobjid = pg_attribute.attrelid
    and pg_depend.refobjsubid = pg_attribute.attnum
  join pg_namespace dependent_ns on dependent_ns.oid = dependent_view.relnamespace
  join pg_namespace source_ns on source_ns.oid = source_table.relnamespace
where source_ns.nspname = '${1:schema}'
  and source_table.relname = '${2:table}'
  and pg_attribute.attnum > 0
  and pg_attribute.attname = '${3:my_column}'
order by 1, 2;
endsnippet

snippet selusage "find view usages" b
select *
from information_schema.view_column_usage
where table_schema = '${1:schema}'
  and table_name = '${2:table}'
  and column_name = '${3:column}'
endsnippet

snippet selvdeps "list dependent views" b
with recursive views as (
  -- get the directly depending views
  select
      v.oid::regclass as view
    , 1 as level
  from pg_depend as d
  join pg_rewrite as r
    on r.oid = d.objid
  join pg_class as v
    on v.oid = r.ev_class
  where v.relkind = 'v'
    and d.classid = 'pg_rewrite'::regclass
    and d.refclassid = 'pg_class'::regclass
    and d.deptype = 'n'
    and d.refobjid = '${0:table}'::regclass
  union all
  -- add the views that depend on these
  select
      v.oid::regclass
    , views.level + 1
  from views
  join pg_depend as d
    on d.refobjid = views.view
  join pg_rewrite as r
    on r.oid = d.objid
  join pg_class as v
    on v.oid = r.ev_class
  where v.relkind = 'v'
    and d.classid = 'pg_rewrite'::regclass
    and d.refclassid = 'pg_class'::regclass
    and d.deptype = 'n'
    and v.oid <> views.view -- avoid loop
)
select view
  -- select format('create view %s as%s', view, pg_get_viewdef(view))
from views
group by view
order by max(level)
endsnippet

# vim:ft=snippets:
